# Discord Watcher Bot - PRD

## PROJECT OVERVIEW

Build a Discord bot that continuously watches for messages, collects them with context, processes them through acpreact (using kilo CLI as the execution engine), and responds with contextually-generated jokes in Discord channels.

**Current State**: Bot runs, connects to Discord, collects messages, debounces them, and passes to ACPProtocol. Handler registers tellRelevantJoke tool. However, execution path needs validation - kilo CLI integration, tool call execution, error handling, and recovery mechanisms need verification and hardening.

**Key Dependencies**:
- discord.js (v14.14.1): Discord API client
- acpreact (v1.0.4): ACP protocol implementation with kilo/opencode CLI spawning
- @kilocode/cli (v1.0.0): kilo command-line interface for processing
- @anthropic-ai/sdk, @opencode-ai/sdk, @opencode-ai/plugin: Indirect dependencies via acpreact

---

## EXECUTION PLAN - DEPENDENCY GRAPH

### WAVE 1: FOUNDATION & VALIDATION (Run in Parallel)

#### Task 1.1: Verify kilo CLI Availability
**Blocks**: 2.1, 3.1
**Description**:
- Execute `kilo --version` to confirm kilo CLI is installed and accessible
- Test kilo with simple prompt: `echo "hello" | kilo run "respond with json"`
- Verify CLI spawning works with correct args array: `['run', prompt]`
- Verify stdin/stdout pipes work as expected
- Capture error cases: CLI not found, CLI timeout, CLI exit codes
- **Edge cases**: CLI hangs, returns non-zero code, returns non-JSON, large output buffering
- **Acceptance**: kilo responds with valid output, no spawning errors

#### Task 1.2: Verify acpreact Core Functionality
**Blocks**: 2.1, 3.1
**Description**:
- Test ACPProtocol instantiation with instruction
- Register a test tool with dummy handler
- Call registerTool, verify toolWhitelist updates
- Test createInitializeResponse output structure
- Test callTool execution with registered tool
- Test tool validation (reject non-whitelisted tools)
- Test parseToolCalls with various JSON-RPC formats
- **Edge cases**: Empty toolWhitelist, malformed JSON output, multiple tool calls in output
- **Acceptance**: Protocol creates/registers/validates/executes tools correctly

#### Task 1.3: Verify Discord.js Message Collection
**Blocks**: 2.2, 3.2
**Description**:
- Verify bot connects to Discord with valid token
- Capture incoming messages via MessageCreate event
- Verify message structure: id, content, author.tag, channelId, timestamp
- Test debounce timer: collect 5 messages, verify pending accumulates, verify timeout triggers batch
- Verify pendingMessages array fills and clears correctly
- **Edge cases**: Bot messages (should be filtered), empty content, malformed timestamps, rapid fire messages
- **Acceptance**: Messages collected in pending array within 10s debounce window

#### Task 1.4: Verify Global State Exposure
**Blocks**: 2.3, 3.3
**Description**:
- Verify global.discordBot object exposes: start, stop, getPending, reload, sendMessage
- Test getPending returns current pendingMessages array
- Test each method is callable and doesn't throw
- **Edge cases**: Called before initialization, called after stop, called during reload
- **Acceptance**: All methods exist and are accessible

---

### WAVE 2: INTEGRATION & EXECUTION (Depends on Wave 1 completing)

#### Task 2.1: End-to-End ACPProtocol → kilo → Tool Execution
**Blocks**: 3.1
**Blocked By**: 1.1, 1.2
**Description**:
- Create test handler that calls acp.process() with real chat content
- Register tellRelevantJoke tool with console.log side effect
- Pass real formatted chat batch to acp.process()
- Verify kilo CLI spawns with correct prompt construction
- Verify parseToolCalls finds tellRelevantJoke calls in kilo output
- Verify tool executes (console logs appear)
- Verify result structure: { text, toolCalls, logs }
- **Edge cases**: Tool not in whitelist, no tools called by kilo, malformed tool params, tool execution fails
- **Dependency issues**: Kilo CLI not found (Task 1.1), Tool registration missing (Task 1.2)
- **Acceptance**: Real tool call executed, logged output captured

#### Task 2.2: Message Flow: Collection → Batch → Process
**Blocks**: 3.2
**Blocked By**: 1.3, 1.4
**Description**:
- Send 3+ test messages to Discord channel where bot listens
- Verify each message added to pendingMessages
- Wait for debounce timeout (10s)
- Verify processBatch called automatically
- Verify messageHandler invoked with correct batch
- Verify chatContent formatted correctly: [HH:MM] author: content
- Verify acp object passed to handler
- **Edge cases**: Messages with @mentions, code blocks, emojis, links, empty content, bot own messages
- **Dependency issues**: Bot connection fails (Task 1.3), Handler not loaded (Task 1.4)
- **Acceptance**: Message batch processed within debounce window

#### Task 2.3: Tool → Discord Response
**Blocks**: 3.3
**Blocked By**: 1.1, 1.4
**Description**:
- Mock Discord channel send behavior or use real channel
- From handler, call global.discordBot.sendMessage(channelId, content)
- Verify message appears in Discord or mock logs success
- Verify return value: { success: true }
- Test failure case: invalid channelId, missing channel
- Verify return value: { success: false, error: ... }
- **Edge cases**: Channel deleted mid-send, permission denied, message too long (2000 char limit)
- **Dependency issues**: Discord connection fails (Task 1.3)
- **Acceptance**: Messages send successfully, failures return error structure

#### Task 2.4: Handler Hot Reload
**Blocks**: 3.4
**Blocked By**: 1.4
**Description**:
- Modify handler.js content
- Verify watchFile triggers on change
- Verify loadHandler runs, imports fresh module
- Verify messageHandler function updates to new version
- Verify new tool registrations take effect
- Test that old version not cached
- Verify reload log outputs
- **Edge cases**: Reload during processing, reload syntax error, reload missing export
- **Dependency issues**: watchFile not triggering, import caching persists
- **Acceptance**: Handler changes reflected without bot restart

---

### WAVE 3: ERROR HANDLING & RECOVERY (Depends on Wave 2 completing)

#### Task 3.1: ACPProtocol CLI Failure Recovery
**Blocks**: 4.1
**Blocked By**: 2.1
**Description**:
- Simulate kilo CLI crash: spawn child that exits non-zero
- Verify rejection handler catches and returns error structure
- Verify process() resolves (not rejects) with error field
- Test timeout scenario: spawn hangs for 35s, verify timeout error
- Test stderr capture and error message propagation
- Verify toolCallLog continues to populate
- **Edge cases**: Partial output before crash, stderr-only output, zero-length stdout
- **Acceptance**: CLI failures don't crash bot, errors logged and returned

#### Task 3.2: Message Processing Failure Recovery
**Blocks**: 4.1
**Blocked By**: 2.2
**Description**:
- Simulate handler error: throw exception in onMessages
- Verify try-catch in processBatch catches and logs
- Verify pending messages remain if processing fails
- Verify bot continues accepting new messages
- Test retry scenario: if first process fails, next batch should still try
- **Edge cases**: Exception mid-tool-call, exception in tool handler callback
- **Acceptance**: Processing errors don't drop messages or stop bot

#### Task 3.3: Discord Send Failure Recovery
**Blocks**: 4.1
**Blocked By**: 2.3
**Description**:
- Simulate channel fetch failure: invalid channelId
- Verify sendMessage catches error and returns { success: false }
- Verify error message captured in response
- Test network error scenario
- Verify bot state remains healthy after send failure
- Verify pending messages not lost
- **Edge cases**: Channel exists but no send permission, connection drops mid-send
- **Acceptance**: Send failures isolated, no state corruption

#### Task 3.4: State Corruption Detection
**Blocks**: 4.1
**Blocked By**: 1.4
**Description**:
- Detect scenarios where state becomes invalid:
  - debounceTimer orphaned if reload happens
  - pendingMessages accumulate without processing
  - messageHandler set to null mid-execution
  - client in inconsistent state after connection drop
- For each: implement recovery logic
  - Clear orphaned timers on reload
  - Drain stuck messages if debounce exceeds 2x window
  - Reload handler if null
  - Recreate client connection on disconnect
- Add monitoring checkpoints: log state snapshots periodically
- **Edge cases**: Recovery loops (fixed: max 3 retry attempts), partial recovery failure
- **Acceptance**: State corruption detected and recovered, no manual intervention needed

#### Task 3.5: Graceful Shutdown
**Blocks**: 4.1
**Blocked By**: 2.4, 3.2
**Description**:
- Test stop() function completeness
- Verify debounceTimer cleared
- Verify pending batch processed before stopping (drain)
- Verify client.destroy() completes
- Verify isRunning set to false
- Test stop during active processing
- Test stop during reload
- **Edge cases**: Stop called twice, stop called before start
- **Acceptance**: Shutdown completes cleanly, no dangling timers

---

### WAVE 4: VERIFICATION & DOCUMENTATION (Depends on Wave 3 completing)

#### Task 4.1: Integration Test - Full Cycle
**Blocks**: (Terminal task)
**Blocked By**: 3.1, 3.2, 3.3, 3.4, 3.5
**Description**:
- Execute complete end-to-end scenario:
  1. Start bot
  2. Connect to real Discord channel
  3. Send 5 test messages with conversation context
  4. Wait for debounce
  5. Verify acp.process() executes
  6. Verify kilo CLI called
  7. Verify tellRelevantJoke tool registered
  8. Verify joke output appears in Discord (or captured in logs)
  9. Verify all logs clean, no errors
  10. Send 5 more messages, repeat
  11. Modify handler.js, verify hot reload
  12. Send message to trigger new version
  13. Verify new behavior
  14. Stop bot gracefully
  15. Verify cleanup complete
- **Scenarios**:
  - Light conversation (should generate joke)
  - Serious discussion (should not generate joke)
  - Mixed conversation (context-aware)
  - Rapid messages (batched correctly)
  - Slow messages (timeout triggers)
  - Handler syntax error (recovered on reload)
  - Network interruption (recovered)
- **Acceptance**: All scenarios pass, bot stable, jokes appropriate, recovery works

#### Task 4.2: Code Quality & Cleanup
**Blocks**: (Terminal task)
**Blocked By**: 4.1
**Description**:
- Review bot.js for dead code, consolidate duplicates
- Review handler.js for clarity and error paths
- Verify no hardcoded values (except channel logic which requires user config)
- Verify all functions under 200 lines (bot.js ~130, handler.js ~40)
- Remove console.log spam, keep only essential logs
- Verify global.discordBot exposure complete and clean
- Check for uncontained promises or floating async calls
- Verify all error paths logged
- **Acceptance**: Code clean, readable, maintainable

---

## TESTING STRATEGY BY COMPONENT

### Component: Discord Connection
- **Path 1 (Success)**: Valid token, connect, receive ready event, receive messages
- **Path 2 (Fail)**: Invalid token, expect connection error logged, bot not marked running
- **Path 3 (Recover)**: Connection drops, detect via error event, attempt reconnect (requires implementation)
- **Boundary**: Max message backlog while disconnected (currently unbounded - needs limit)

### Component: Message Collection & Batching
- **Path 1 (Success)**: 1 message → debounce 10s → batch processes
- **Path 2 (Success)**: 5 messages rapid → all in batch → process once
- **Path 3 (Success)**: 10 messages rapid then 5s silence then 5s wait → all 10 in batch → process
- **Edge**: Empty message batch somehow formed (should never happen - verify guard)
- **Edge**: Message with null author (should skip gracefully)
- **Edge**: Timestamp in future or past (should use Date.now() consistently)

### Component: ACPProtocol + kilo Integration
- **Path 1 (Success)**: prompt → spawn kilo → receive JSON-RPC → parse → execute tool
- **Path 2 (Fail)**: kilo not found → spawn error → reject promise → catch logs
- **Path 3 (Fail)**: kilo timeout after 30s → abort → timeout error
- **Path 4 (Partial)**: kilo outputs partial JSON → parseToolCalls skips incomplete
- **Edge**: No tools in whitelist → kilo still called (will it output nothing? verify)
- **Edge**: Multiple tool calls in one output → all parsed and executed in sequence

### Component: Tool Execution (tellRelevantJoke)
- **Path 1 (Success)**: Tool called with joke param → Discord sendMessage called → returns success
- **Path 2 (Fail)**: sendMessage fails → tool catches → returns error structure → process continues
- **Path 3 (Reject)**: Tool not in whitelist → callTool throws → process catches logs → no crash
- **Edge**: Tool params invalid JSON schema → still passes through (acpreact doesn't validate schema - kilo does)

### Component: Global State & Lifecycle
- **Path 1 (Start→Running)**: start() → loadHandler → Discord connect → ready event → isRunning = true
- **Path 2 (Running→Stop)**: stop() → clear timer → drain messages → destroy client → isRunning = false
- **Path 3 (Reload)**: watchFile triggers → loadHandler → fresh module → messageHandler updated → new tools active
- **Path 4 (Reload during process)**: If reload triggered while processBatch executing → handler import race (need timeout guard)

---

## KNOWN UNKNOWNS & ASSUMPTIONS

### Unknown 1: Kilo CLI Behavior
- **Question**: Does kilo accept prompt via args `['run', prompt]` or stdin?
  - **Current code**: Uses args, ignores stdin
  - **Alternative**: Check kilo docs, may need stdin
  - **Validation**: Task 1.1 tests this
- **Question**: What does kilo output format look like?
  - **Current assumption**: JSON-RPC format with method/params
  - **Reality**: parseToolCalls looks for JSON objects with jsonrpc/method/params fields
  - **Validation**: Task 2.1 tests real output parsing

### Unknown 2: Instruction Effectiveness
- **Question**: Does the instruction provided to ACPProtocol actually influence kilo's behavior?
  - **Current code**: Instruction passed in options to process()
  - **Reality**: Need to verify kilo receives and uses it
  - **Validation**: Task 4.1 tests if jokes are contextually appropriate (validation of instruction working)

### Unknown 3: Tool Execution During Process
- **Question**: Are tool calls executed inside acp.process() or returned for external execution?
  - **Current code**: Inside process(), tool called immediately in loop
  - **Assumption**: This is correct behavior
  - **Validation**: Task 2.1 tests tool side effects during process()

### Unknown 4: Message Timestamp Consistency
- **Question**: Should timestamp be Date.now() (collection time) or message.timestamp (Discord time)?
  - **Current code**: Uses Date.now() at collection time
  - **Impact**: May cause time ordering issues if Discord timestamps differ significantly
  - **Assumption**: Collection time is fine for now
  - **Validation**: Task 4.1 with mixed rapid/slow messages confirms

### Unknown 5: Channel Permissions
- **Question**: Does bot have required Discord permissions to send messages?
  - **Current code**: Assumes permission, catches error if denied
  - **Reality**: Depends on guild configuration
  - **Validation**: Task 2.3 tests send failure path

---

## ASSUMPTIONS TO VALIDATE

1. **Assumption**: Kilo CLI installed in node_modules/.bin and accessible via spawn
   - **Validates**: Task 1.1

2. **Assumption**: Chat context is sufficient for joke appropriateness (5-10 messages with timestamps)
   - **Validates**: Task 4.1 (scenario: appropriate joke generation)

3. **Assumption**: 10-second debounce window balances responsiveness vs batching efficiency
   - **Validates**: Task 4.1 (scenario: message timing tests)

4. **Assumption**: Hot reload with watchFile is fast enough to not interfere with message processing
   - **Validates**: Task 2.4 (concurrent reload and message arrival)

5. **Assumption**: Global state exposure is secure enough (no sensitive data exposed, only control functions)
   - **Validates**: Task 1.4 (state exposure structure)

---

## EDGE CASES & CORNER CASES

### Message Content Edge Cases
- Message contains only whitespace
- Message contains @mentions of 50+ users
- Message contains code block (triple backtick)
- Message contains emoji only
- Message contains URL with query params
- Message contains newlines (multi-line)
- Message length > 2000 chars (Discord limit)

### Timing Edge Cases
- Message arrives at exact debounce boundary (10s)
- 2nd message arrives 9.99s after first (all in batch)
- 2nd message arrives 10.01s after first (separate batch)
- Stop() called while debounceTimer pending
- Stop() called during acp.process() execution
- Reload called during acp.process() execution
- Handler file modified twice within 1s

### Concurrency Edge Cases
- 100 messages arrive within 100ms
- Message arrives while previous batch still processing
- Reload triggered while processing batch
- Discord connection drops during processBatch
- Discord connection drops during sendMessage

### State Corruption Scenarios
- debounceTimer orphaned (reload without cleanup)
- pendingMessages array grows unbounded if batching never triggers
- messageHandler set to null (import fails silently)
- client object in partially destroyed state
- toolCallLog grows unbounded (memory leak potential)

### Error Propagation Paths
- kilo outputs non-JSON
- kilo outputs JSON but no jsonrpc field
- kilo outputs JSON-RPC with missing method field
- Tool execution throws exception
- Tool execution returns undefined
- channel.send() throws before returning promise
- channel.send() promise rejects async

---

## CONFIGURATION & ENVIRONMENT

### Environment Variables
- `DISCORD_BOT_TOKEN`: Required, validates in start()

### Configuration Constants
- `DEBOUNCE_MS`: 10000 (10 seconds, hardcoded)
- CLI timeout: 30000ms (hardcoded in acpreact)
- kilo CLI: 'kilo' (hardcoded, must be in PATH)

### Configurable Instruction
- Currently hardcoded in bot.js lines 80-81
- Should be moved to env var or config file
- Allows behavior change without code edit

---

## DEPENDENCIES & INTEGRATION POINTS

### Internal Dependencies
- bot.js → handler.js: loadHandler imports fresh module, watches for changes
- handler.js → bot.js: Uses global.discordBot.sendMessage()
- handler.js → acpreact: Uses acp.registerTool(), acp.process()

### External Dependencies
- discord.js: MessageCreate events, channel.send(), client lifecycle
- acpreact: ACPProtocol class, process(), registerTool(), parseToolCalls()
- kilo CLI: Spawned subprocess, receives prompt, outputs JSON-RPC
- Anthropic SDK: Indirectly used by kilo
- OpenCode SDK: Indirectly used by kilo

### State Transitions
```
[Start]
  ↓
loadHandler() → Handler loaded or error logged
  ↓
Discord connect → isRunning = true → [Ready]
  ↓
Messages arrive → pendingMessages accumulates
  ↓
Debounce timeout → processBatch()
  ↓
acp.process() → kilo spawned → output parsed → tool executed
  ↓
Discord sendMessage() → Message in chat or error logged
  ↓
Watch handler.js → File change detected → loadHandler() (no isRunning reset)
  ↓
[Running forever] (until stop() called or crash)
```

---

## ACCEPTANCE CRITERIA

### Functional Requirements
- Bot connects to Discord with provided token
- Bot collects messages from all channels it has access to
- Bot batches messages with 10-second debounce
- Bot passes chat context to acpreact ACP protocol
- Bot executes kilo CLI with instruction and chat content
- Bot parses JSON-RPC tool calls from kilo output
- Bot executes tellRelevantJoke tool when called
- Bot sends joke response to Discord channel
- Bot reloads handler.js on file change without restart
- Bot continues operating after errors

### Non-Functional Requirements
- No unhandled promise rejections
- All crashes prevented via try-catch at boundaries
- Error messages logged with timestamp and context
- State accessible via global.discordBot for debugging
- No memory leaks (periodic state cleanup)
- Message response latency < 15 seconds (debounce + processing)
- System survives 24+ hours continuous operation

### Testing Requirements
- All success paths tested with real services
- All failure paths tested with real error conditions
- Recovery paths tested with real interruption scenarios
- No mock/stub/fake services used
- No unit tests on disk
- All execution witnessed and logged

---

## COMPLETION DEFINITION

Work is complete when:
1. All Wave 1-4 tasks passing (verified by execution)
2. Integration test (4.1) executed successfully with witnessed output
3. All scenarios from Wave 3 error handling tested and recovered
4. Code cleanup (4.2) complete
5. Bot runs successfully in real Discord channel
6. Joke generation observed and contextually appropriate
7. No remaining manual steps for user
8. System stable for continuous operation

